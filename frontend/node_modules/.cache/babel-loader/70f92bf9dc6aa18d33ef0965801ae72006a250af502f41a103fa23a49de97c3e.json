{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchFromUrl = exports.parseBlob = exports.parseReadableStream = exports.parseNodeStream = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = void 0;\nconst initDebug = require(\"debug\");\nconst mm = require(\"music-metadata/lib/core\");\nconst readable_web_to_node_stream_1 = require(\"readable-web-to-node-stream\");\nconst debug = initDebug('music-metadata-browser:main');\nvar core_1 = require(\"music-metadata/lib/core\");\nObject.defineProperty(exports, \"parseBuffer\", {\n  enumerable: true,\n  get: function () {\n    return core_1.parseBuffer;\n  }\n});\nObject.defineProperty(exports, \"parseFromTokenizer\", {\n  enumerable: true,\n  get: function () {\n    return core_1.parseFromTokenizer;\n  }\n});\nObject.defineProperty(exports, \"orderTags\", {\n  enumerable: true,\n  get: function () {\n    return core_1.orderTags;\n  }\n});\nObject.defineProperty(exports, \"ratingToStars\", {\n  enumerable: true,\n  get: function () {\n    return core_1.ratingToStars;\n  }\n});\nObject.defineProperty(exports, \"selectCover\", {\n  enumerable: true,\n  get: function () {\n    return core_1.selectCover;\n  }\n});\n/**\r\n * Parse audio Stream\r\n * @param stream - ReadableStream\r\n * @param contentType - MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\nexports.parseNodeStream = mm.parseStream;\n/**\r\n * Parse Web API ReadableStream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\r\n * @param stream - ReadableStream (web stream according WTWG Streams Standard)\r\n * @param fileInfo FileInfo object or MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\nasync function parseReadableStream(stream, fileInfo, options) {\n  const ns = new readable_web_to_node_stream_1.ReadableWebToNodeStream(stream);\n  const res = await (0, exports.parseNodeStream)(ns, typeof fileInfo === 'string' ? {\n    mimeType: fileInfo\n  } : fileInfo, options);\n  await ns.close();\n  return res;\n}\nexports.parseReadableStream = parseReadableStream;\n/**\r\n * Parse Web API File\r\n * @param blob - Blob to parse\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\nasync function parseBlob(blob, options) {\n  const fileInfo = {\n    mimeType: blob.type,\n    size: blob.size\n  };\n  if (blob instanceof File) {\n    fileInfo.path = blob.name;\n  }\n  const stream = blob.stream ? blob.stream() : convertBlobToReadableStream(blob);\n  return parseReadableStream(stream, {\n    mimeType: blob.type,\n    size: blob.size\n  }, options);\n}\nexports.parseBlob = parseBlob;\n/**\r\n * Convert Blob to ReadableStream\r\n * Fallback for Safari versions < 14.1\r\n * @param blob\r\n */\nfunction convertBlobToReadableStream(blob) {\n  const fileReader = new FileReader();\n  return new ReadableStream({\n    start(controller) {\n      // The following function handles each data chunk\n      fileReader.onloadend = event => {\n        let data = event.target.result;\n        if (data instanceof ArrayBuffer) {\n          data = new Uint8Array(data);\n        }\n        controller.enqueue(data);\n        controller.close();\n      };\n      fileReader.onerror = error => {\n        controller.close();\n      };\n      fileReader.onabort = error => {\n        controller.close();\n      };\n      fileReader.readAsArrayBuffer(blob);\n    }\n  });\n}\n/**\r\n * Parse fetched file, using the Web Fetch API\r\n * @param audioTrackUrl - URL to download the audio track from\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\nasync function fetchFromUrl(audioTrackUrl, options) {\n  const response = await fetch(audioTrackUrl);\n  const fileInfo = {\n    size: parseInt(response.headers.get('Content-Length'), 10),\n    mimeType: response.headers.get('Content-Type')\n  };\n  if (response.ok) {\n    if (response.body) {\n      const res = await parseReadableStream(response.body, fileInfo, options);\n      debug('Closing HTTP-readable-stream...');\n      if (!response.body.locked) {\n        // Prevent error in Firefox\n        await response.body.cancel();\n      }\n      debug('HTTP-readable-stream closed.');\n      return res;\n    } else {\n      // Fall back on Blob\n      return parseBlob(await response.blob(), options);\n    }\n  } else {\n    throw new Error(`HTTP error status=${response.status}: ${response.statusText}`);\n  }\n}\nexports.fetchFromUrl = fetchFromUrl;","map":{"version":3,"names":["Object","defineProperty","exports","value","fetchFromUrl","parseBlob","parseReadableStream","parseNodeStream","selectCover","ratingToStars","orderTags","parseFromTokenizer","parseBuffer","initDebug","require","mm","readable_web_to_node_stream_1","debug","core_1","enumerable","get","parseStream","stream","fileInfo","options","ns","ReadableWebToNodeStream","res","mimeType","close","blob","type","size","File","path","name","convertBlobToReadableStream","fileReader","FileReader","ReadableStream","start","controller","onloadend","event","data","target","result","ArrayBuffer","Uint8Array","enqueue","onerror","error","onabort","readAsArrayBuffer","audioTrackUrl","response","fetch","parseInt","headers","ok","body","locked","cancel","Error","status","statusText"],"sources":["C:/Users/erb19/OneDrive/Documents/Projects/vortex-player/frontend/node_modules/music-metadata-browser/lib/index.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.fetchFromUrl = exports.parseBlob = exports.parseReadableStream = exports.parseNodeStream = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = void 0;\r\nconst initDebug = require(\"debug\");\r\nconst mm = require(\"music-metadata/lib/core\");\r\nconst readable_web_to_node_stream_1 = require(\"readable-web-to-node-stream\");\r\nconst debug = initDebug('music-metadata-browser:main');\r\nvar core_1 = require(\"music-metadata/lib/core\");\r\nObject.defineProperty(exports, \"parseBuffer\", { enumerable: true, get: function () { return core_1.parseBuffer; } });\r\nObject.defineProperty(exports, \"parseFromTokenizer\", { enumerable: true, get: function () { return core_1.parseFromTokenizer; } });\r\nObject.defineProperty(exports, \"orderTags\", { enumerable: true, get: function () { return core_1.orderTags; } });\r\nObject.defineProperty(exports, \"ratingToStars\", { enumerable: true, get: function () { return core_1.ratingToStars; } });\r\nObject.defineProperty(exports, \"selectCover\", { enumerable: true, get: function () { return core_1.selectCover; } });\r\n/**\r\n * Parse audio Stream\r\n * @param stream - ReadableStream\r\n * @param contentType - MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nexports.parseNodeStream = mm.parseStream;\r\n/**\r\n * Parse Web API ReadableStream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\r\n * @param stream - ReadableStream (web stream according WTWG Streams Standard)\r\n * @param fileInfo FileInfo object or MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nasync function parseReadableStream(stream, fileInfo, options) {\r\n    const ns = new readable_web_to_node_stream_1.ReadableWebToNodeStream(stream);\r\n    const res = await (0, exports.parseNodeStream)(ns, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo, options);\r\n    await ns.close();\r\n    return res;\r\n}\r\nexports.parseReadableStream = parseReadableStream;\r\n/**\r\n * Parse Web API File\r\n * @param blob - Blob to parse\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nasync function parseBlob(blob, options) {\r\n    const fileInfo = { mimeType: blob.type, size: blob.size };\r\n    if (blob instanceof File) {\r\n        fileInfo.path = blob.name;\r\n    }\r\n    const stream = (blob.stream ? blob.stream() : convertBlobToReadableStream(blob));\r\n    return parseReadableStream(stream, { mimeType: blob.type, size: blob.size }, options);\r\n}\r\nexports.parseBlob = parseBlob;\r\n/**\r\n * Convert Blob to ReadableStream\r\n * Fallback for Safari versions < 14.1\r\n * @param blob\r\n */\r\nfunction convertBlobToReadableStream(blob) {\r\n    const fileReader = new FileReader();\r\n    return new ReadableStream({\r\n        start(controller) {\r\n            // The following function handles each data chunk\r\n            fileReader.onloadend = event => {\r\n                let data = event.target.result;\r\n                if (data instanceof ArrayBuffer) {\r\n                    data = new Uint8Array(data);\r\n                }\r\n                controller.enqueue(data);\r\n                controller.close();\r\n            };\r\n            fileReader.onerror = error => {\r\n                controller.close();\r\n            };\r\n            fileReader.onabort = error => {\r\n                controller.close();\r\n            };\r\n            fileReader.readAsArrayBuffer(blob);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Parse fetched file, using the Web Fetch API\r\n * @param audioTrackUrl - URL to download the audio track from\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nasync function fetchFromUrl(audioTrackUrl, options) {\r\n    const response = await fetch(audioTrackUrl);\r\n    const fileInfo = {\r\n        size: parseInt(response.headers.get('Content-Length'), 10),\r\n        mimeType: response.headers.get('Content-Type')\r\n    };\r\n    if (response.ok) {\r\n        if (response.body) {\r\n            const res = await parseReadableStream(response.body, fileInfo, options);\r\n            debug('Closing HTTP-readable-stream...');\r\n            if (!response.body.locked) { // Prevent error in Firefox\r\n                await response.body.cancel();\r\n            }\r\n            debug('HTTP-readable-stream closed.');\r\n            return res;\r\n        }\r\n        else {\r\n            // Fall back on Blob\r\n            return parseBlob(await response.blob(), options);\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(`HTTP error status=${response.status}: ${response.statusText}`);\r\n    }\r\n}\r\nexports.fetchFromUrl = fetchFromUrl;\r\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,YAAY,GAAGF,OAAO,CAACG,SAAS,GAAGH,OAAO,CAACI,mBAAmB,GAAGJ,OAAO,CAACK,eAAe,GAAGL,OAAO,CAACM,WAAW,GAAGN,OAAO,CAACO,aAAa,GAAGP,OAAO,CAACQ,SAAS,GAAGR,OAAO,CAACS,kBAAkB,GAAGT,OAAO,CAACU,WAAW,GAAG,KAAK,CAAC;AAC9N,MAAMC,SAAS,GAAGC,OAAO,CAAC,OAAO,CAAC;AAClC,MAAMC,EAAE,GAAGD,OAAO,CAAC,yBAAyB,CAAC;AAC7C,MAAME,6BAA6B,GAAGF,OAAO,CAAC,6BAA6B,CAAC;AAC5E,MAAMG,KAAK,GAAGJ,SAAS,CAAC,6BAA6B,CAAC;AACtD,IAAIK,MAAM,GAAGJ,OAAO,CAAC,yBAAyB,CAAC;AAC/Cd,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,aAAa,EAAE;EAAEiB,UAAU,EAAE,IAAI;EAAEC,GAAG,EAAE,SAAAA,CAAA,EAAY;IAAE,OAAOF,MAAM,CAACN,WAAW;EAAE;AAAE,CAAC,CAAC;AACpHZ,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,oBAAoB,EAAE;EAAEiB,UAAU,EAAE,IAAI;EAAEC,GAAG,EAAE,SAAAA,CAAA,EAAY;IAAE,OAAOF,MAAM,CAACP,kBAAkB;EAAE;AAAE,CAAC,CAAC;AAClIX,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,WAAW,EAAE;EAAEiB,UAAU,EAAE,IAAI;EAAEC,GAAG,EAAE,SAAAA,CAAA,EAAY;IAAE,OAAOF,MAAM,CAACR,SAAS;EAAE;AAAE,CAAC,CAAC;AAChHV,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,eAAe,EAAE;EAAEiB,UAAU,EAAE,IAAI;EAAEC,GAAG,EAAE,SAAAA,CAAA,EAAY;IAAE,OAAOF,MAAM,CAACT,aAAa;EAAE;AAAE,CAAC,CAAC;AACxHT,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,aAAa,EAAE;EAAEiB,UAAU,EAAE,IAAI;EAAEC,GAAG,EAAE,SAAAA,CAAA,EAAY;IAAE,OAAOF,MAAM,CAACV,WAAW;EAAE;AAAE,CAAC,CAAC;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACAN,OAAO,CAACK,eAAe,GAAGQ,EAAE,CAACM,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAef,mBAAmBA,CAACgB,MAAM,EAAEC,QAAQ,EAAEC,OAAO,EAAE;EAC1D,MAAMC,EAAE,GAAG,IAAIT,6BAA6B,CAACU,uBAAuB,CAACJ,MAAM,CAAC;EAC5E,MAAMK,GAAG,GAAG,MAAM,CAAC,CAAC,EAAEzB,OAAO,CAACK,eAAe,EAAEkB,EAAE,EAAE,OAAOF,QAAQ,KAAK,QAAQ,GAAG;IAAEK,QAAQ,EAAEL;EAAS,CAAC,GAAGA,QAAQ,EAAEC,OAAO,CAAC;EAC7H,MAAMC,EAAE,CAACI,KAAK,CAAC,CAAC;EAChB,OAAOF,GAAG;AACd;AACAzB,OAAO,CAACI,mBAAmB,GAAGA,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,eAAeD,SAASA,CAACyB,IAAI,EAAEN,OAAO,EAAE;EACpC,MAAMD,QAAQ,GAAG;IAAEK,QAAQ,EAAEE,IAAI,CAACC,IAAI;IAAEC,IAAI,EAAEF,IAAI,CAACE;EAAK,CAAC;EACzD,IAAIF,IAAI,YAAYG,IAAI,EAAE;IACtBV,QAAQ,CAACW,IAAI,GAAGJ,IAAI,CAACK,IAAI;EAC7B;EACA,MAAMb,MAAM,GAAIQ,IAAI,CAACR,MAAM,GAAGQ,IAAI,CAACR,MAAM,CAAC,CAAC,GAAGc,2BAA2B,CAACN,IAAI,CAAE;EAChF,OAAOxB,mBAAmB,CAACgB,MAAM,EAAE;IAAEM,QAAQ,EAAEE,IAAI,CAACC,IAAI;IAAEC,IAAI,EAAEF,IAAI,CAACE;EAAK,CAAC,EAAER,OAAO,CAAC;AACzF;AACAtB,OAAO,CAACG,SAAS,GAAGA,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS+B,2BAA2BA,CAACN,IAAI,EAAE;EACvC,MAAMO,UAAU,GAAG,IAAIC,UAAU,CAAC,CAAC;EACnC,OAAO,IAAIC,cAAc,CAAC;IACtBC,KAAKA,CAACC,UAAU,EAAE;MACd;MACAJ,UAAU,CAACK,SAAS,GAAGC,KAAK,IAAI;QAC5B,IAAIC,IAAI,GAAGD,KAAK,CAACE,MAAM,CAACC,MAAM;QAC9B,IAAIF,IAAI,YAAYG,WAAW,EAAE;UAC7BH,IAAI,GAAG,IAAII,UAAU,CAACJ,IAAI,CAAC;QAC/B;QACAH,UAAU,CAACQ,OAAO,CAACL,IAAI,CAAC;QACxBH,UAAU,CAACZ,KAAK,CAAC,CAAC;MACtB,CAAC;MACDQ,UAAU,CAACa,OAAO,GAAGC,KAAK,IAAI;QAC1BV,UAAU,CAACZ,KAAK,CAAC,CAAC;MACtB,CAAC;MACDQ,UAAU,CAACe,OAAO,GAAGD,KAAK,IAAI;QAC1BV,UAAU,CAACZ,KAAK,CAAC,CAAC;MACtB,CAAC;MACDQ,UAAU,CAACgB,iBAAiB,CAACvB,IAAI,CAAC;IACtC;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe1B,YAAYA,CAACkD,aAAa,EAAE9B,OAAO,EAAE;EAChD,MAAM+B,QAAQ,GAAG,MAAMC,KAAK,CAACF,aAAa,CAAC;EAC3C,MAAM/B,QAAQ,GAAG;IACbS,IAAI,EAAEyB,QAAQ,CAACF,QAAQ,CAACG,OAAO,CAACtC,GAAG,CAAC,gBAAgB,CAAC,EAAE,EAAE,CAAC;IAC1DQ,QAAQ,EAAE2B,QAAQ,CAACG,OAAO,CAACtC,GAAG,CAAC,cAAc;EACjD,CAAC;EACD,IAAImC,QAAQ,CAACI,EAAE,EAAE;IACb,IAAIJ,QAAQ,CAACK,IAAI,EAAE;MACf,MAAMjC,GAAG,GAAG,MAAMrB,mBAAmB,CAACiD,QAAQ,CAACK,IAAI,EAAErC,QAAQ,EAAEC,OAAO,CAAC;MACvEP,KAAK,CAAC,iCAAiC,CAAC;MACxC,IAAI,CAACsC,QAAQ,CAACK,IAAI,CAACC,MAAM,EAAE;QAAE;QACzB,MAAMN,QAAQ,CAACK,IAAI,CAACE,MAAM,CAAC,CAAC;MAChC;MACA7C,KAAK,CAAC,8BAA8B,CAAC;MACrC,OAAOU,GAAG;IACd,CAAC,MACI;MACD;MACA,OAAOtB,SAAS,CAAC,MAAMkD,QAAQ,CAACzB,IAAI,CAAC,CAAC,EAAEN,OAAO,CAAC;IACpD;EACJ,CAAC,MACI;IACD,MAAM,IAAIuC,KAAK,CAAC,qBAAqBR,QAAQ,CAACS,MAAM,KAAKT,QAAQ,CAACU,UAAU,EAAE,CAAC;EACnF;AACJ;AACA/D,OAAO,CAACE,YAAY,GAAGA,YAAY","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}